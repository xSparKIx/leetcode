/**
 * 424. Самая длинная повторяющаяся замена символа
 * 
 * Вам дана строка sи целое число k. Вы можете выбрать любой символ строки и изменить его на любой другой заглавный английский символ.
 * Эту операцию можно выполнять большинство k раз.
 * Верните длину самой длинной подстроки, содержащей ту же букву, которую вы можете получить после выполнения вышеуказанных операций.
 * 
 * Пример 1:
 * 
 * Ввод: s = «ABAB», k = 2
 * Вывод: 4
 * Пояснение: Замените две буквы «A» на две буквы «B» или наоборот.
 * 
 * Пример 2:
 * Ввод: s = "AABABBA", k = 1
 * Вывод: 4
 * 
 * Пояснение: Замените одну 'A' в середине на 'B' и получите "AABBBBA". 
 * Подстрока "BBBB" имеет самые длинные повторяющиеся буквы, а именно 4. 
 * Могут существовать и другие способы получить этот ответ.
 * 
 * Ограничения:
 * 
 * 1 <= s.length <= 105
 * 
 * s состоит только из заглавных английских букв.
 * 0 <= k <= s.length
 * 
 * @see https://leetcode.com/problems/longest-repeating-character-replacement/description/
 */
function characterReplacement(s: string, k: number): number {
  // Максимальная найденная длинна
  let maxLength = 0;
  // Самая повторяющаяся буква, ее количество повторений
  let maxFrequency = 0;
  // Левый индекс (начало скользящего окна, sliding_window)
  let start = 0;
  // Хэш-таблица, которая содержит буквы и количество их повторений
  const hashTable = {};

  // Пробегаемся по каждому элементу строки
  for (let i = 0, length = s.length; i < length; i++) {
    // Добавляем букву в хэш-таблицу/увеличиваем число ее повторений
    hashTable[s[i]] = (hashTable[s[i]] || 0) + 1;
    // Находим самую повторяющуюся букву, количество ее повторений.
    // Для этого просто сравниваем с обновленной записью в хэш-таблице, стала ли она больше максимальной.
    // (при каждой итерации количество повторений буквы меняется и мы просто сравниваем его с максимальным).
    maxFrequency = Math.max(maxFrequency, hashTable[s[i]]);

    // Проверяем стала ли сумма самой повторяющейся буквы + кол-во символов на перестановку больше чем длина скользящего окна
    // Длина скользящего окна: правый индекс - начальный индекс + 1 (так как начинаем подсчет с 0);
    // ! кол-во самой повторяющейся буквы + кол-во символов на перестановку должна ровняться длине скользящего окна. Это будет означать, что все работает корректно.
    // maxFrequency - самая повторяющаяся буква, k - остаток (остальные буквы) значит при их сложении должна получаться длина скользящего окна.
    if (maxFrequency + k < i - start + 1) {
      // Если мы вышли за пределы, то смещаем левую границу и декрементируем количество повторений этой буквы в хэш-таблице.
      hashTable[s[start]]--;
      start++;
    }

    // Сравниваем максимальную длину последовательности с текущим размером скользящего окна и записываем его.
    maxLength = Math.max(maxLength, i - start + 1);
  }

  return maxLength;
}

console.log(characterReplacement("ABCDE", 1));


/**
 * РЕШЕНИЕ
 * 
 * Интуиция
Идея заключается в том, чтобы поддерживать окно (подстроку) и корректировать его по мере итерации по строке. Цель состоит в том, чтобы найти самую длинную подстроку с тем же символом, допуская максимум kзамен.

Подход
Инициализация HashMap:

hashMapинициализируется для отслеживания частоты символов в текущем окне.

Инициализация переменной:

longestинициализируется для отслеживания длины самой длинной подстроки.
maxFreqинициализируется для отслеживания максимальной частоты любого символа, встречающегося в текущем окне.
leftPointerинициализируется как начальная точка скользящего окна.

Основной цикл:

Алгоритм перебирает строку, используя правый указатель.
Для каждого встречающегося символа он увеличивает его частоту в HashMap.

Максимальная частота обновления:

maxFreqобновляется с учетом максимальной частоты встречаемости любого символа на данный момент.

Динамическая регулировка окна:

Если в какой-либо точке размер окна за вычетом максимальной частоты превышает допустимые замены k, это означает, что нам нужно сжать окно с левой стороны.
Левый указатель перемещается, а частота символа в этой позиции уменьшается.

Обновление самой длинной подстроки:

longestобновляется для отслеживания длины самой длинной подстроки с тем же символом.

Результат:

Наконец, функция возвращает длину самой длинной подстроки с тем же символом, что позволяет выполнить максимум kзамен.

Сложность
Временная сложность:
Временная сложность составляет O(N), где N — длина входной строки.

Сложность пространства:
Сложность пространства составляет O(1) с верхней границей O(26) для HashMap.

Код

 */

// const characterReplacement = (s: string, k: number): number => {
//   const hashMap: { [key: string]: number } = {}
//   let longest: number = 0
//   let maxFreq: number = 0
//   let leftPointer: number = 0

//   for (let rightPointer = 0; rightPointer < s.length; rightPointer++) {
//     // Increment the frequency count by 1 upon encountering a character
//     hashMap[s[rightPointer]] = (hashMap[s[rightPointer]] || 0) + 1

//     // Maximum frequency of any character encountered so far in the current window.
//     maxFreq = Math.max(maxFreq, hashMap[s[rightPointer]])

//     // Move the window from the left until reaching `k` replacements
//     if (maxFreq + k < rightPointer - leftPointer + 1) {
//       hashMap[s[leftPointer]]--
//       leftPointer++
//     }

//     // Calculate the longest repeating character
//     longest = Math.max(longest, rightPointer - leftPointer + 1)
//   }

//   return longest
// }